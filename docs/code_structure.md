Code Structure
==============

Documentation is very important, but if anyone were to reach the limits of your software, providing them with a guide of your code and how to dive into it is the next major step for truly usable open source that can grow on it's users. This is a try at explaining Glider's inner workings.

== Macro structure ==

The `lib` folder at the root of the repo has all the code that is loaded when you use Glider in your Gemfile or when you manually require ir. The first filde in there `glider.rb` is just an entry point taking care of requiring all dependencies and importing all required files in the appropriate order. The dependencies used are for contacting AWS, serializing to JSON and from JSON down to Ruby hashes with indifferent access (this is taking from Rails and basically is a special hash where a[:x] == a["x"] which isn't Ruby's default behavior).

The Glider files that are required after the dependencies implement behaviour for specific parts of the Glider module, as follows:

* `component.rb` is the base class that you'd inherit from in your own code to implement workers or deciders. This is a common class because all actions in SWF are related to a workflow and a task (either a decision or a worker task). Every class of this instance represents a specific task in the workflow. When the poller received from SWF API a new event, it get's the task, event, the control value and the completed event and uses those objects to instantiate the component and then run the applicable method (e.g. activity_method) to process the work. Some of the instance variables like control and completed event only apply for deciders. It's because of this use of classes and instances that you can use something like `task.fail!` because `task` is actually an instance attribute reader with a value defined on instantiation.
* `process_manager.rb` is added to handle the execution of multiple instances of the same component in paralell. It can handle forking and threading. A block to be executed (it's expected to be an infinite loop) is instantiated as many times as needed in a different process or fork. Signal handling for graceful exit and automatic restart of failing children is handled here, allowing you to simplify deployments.
* `utils.rb` provies convenience methods for starting workflows, sending [signals](http://docs.aws.amazon.com/amazonswf/latest/developerguide/swf-dg-signals.html) and a common logging method used accross the gem that is useful to define custom logging formats, change the logging detail or redirect output.
* `activities.rb` implements the behaviour specific to workers activities (as opposed to deciders), for instance the class method to register an activity and the default values, it also has a method that takes the acitivity's input and tries to parse it as JSON in which case your method get's a hash with indifferent access if your workflows use JSON to communicate. It also implement the loop block to constantly poll for events of that specific activity. This poller includes signal handling for graceful exit and is the one that instantiates your classes for each event as outlined in the previos explanation. The poller implemented here is a block that is then registered with the process manager to be executed.
* `workflows.rb` provides methods for defining a workflow (and the defaulg values) and it's deciders. It also implements the pollers for this deciders and registers them with the process manager. It defines instance attributed readers for the event that just completed and the control value. It also takes care of trying to extract the event data based on the type of event. For example, if the event is `:workflow_execution_started` then the relevant data is the input and that's whats passed to the decider method. However, if the method were `:activity_task_failed` the relevant data would be the reason of the failure or in the case of `:activity_task_completed` the result of the task.
